---
title: "Principles of writing software I'm taking into 2025"
date: "13th December 2024"
author: "Rithul Kamesh"
tags: ["programming", "software-development"]
---

As we approach 2025, my focus is on writing software that’s precise, efficient, and clear. It's about creating solutions that are maintainable, scalable, and purposeful—because, apparently, ‘just getting it to work’ isn’t enough anymore.

### 1 - Focus on Memory, Not Binary Size

Let’s be real—your binary size isn’t the giant problem it used to be. In a world where we all have SSDs and can scale to infinity in the cloud, obsessing over shaving off a few kilobytes seems a bit... outdated? Instead, let’s focus on memory. Managing your application’s memory—like optimizing heap usage, preventing memory leaks, and caching effectively—will make a much bigger impact on performance and scalability. At the end of the day, memory optimization ensures smoother performance, better scaling under load, and—drumroll, please—a more responsive user experience. So, next time you worry about that extra 100 bytes, remember that your app would prefer if you spent that time making it run like a charm instead.

### 2 - Productivity Over Show

You know the type—the “neovim gang” that insists on doing everything with 17 keyboard shortcuts while ignoring the fact that they’re spending 10 minutes just to open a file? Yeah, I used to be one of them. But here’s the thing: while I love tech that looks cool, I’ve realized the best setup isn’t about being able to list 20 obscure plugins, but about staying productive. And for me, that’s about not using the mouse (seriously, when’s the last time a mouse was actually *necessary*?). Getting in the zone, being able to code without distractions, and keeping my workflow smooth has become the real goal. If you’re spending more time configuring your editor than writing code, maybe it's time to re-think that 'productivity' setup.

### 3 - Focus on What You Love, Not What You Think You *Should* Love

The tech world loves to tell you what’s "hot" and what you "should" be learning. JavaScript is the king, Python is the future, and don’t even get me started on the buzzword buffet of "blockchain," "AI," and "microservices." But here’s a secret: if you don’t enjoy what you’re working on, no framework or shiny new tech will save you from burnout. The best code you’ll ever write is the code you care about. Whether it’s building mobile apps, tinkering with hardware, or just optimizing the smallest bits of a web page, focusing on what excites you is the key to consistent growth. Forget trying to catch up with everyone else; focus on your own journey, and you might just end up ahead.

### 4 - Write Code You’d Actually Read Later

You’ve seen it—the “code” that looks more like a jumbled mess of cryptic variables and fragile logic that no one, including future-you, will understand. Writing code to *impress* someone (especially in the short term) is a road to nowhere. Instead, write code you'd actually want to read again in six months. It’s not about coming up with the most mind-blowing one-liner or cramming all the functionality into a single file; it’s about being kind to yourself in the future. Clear, well-structured code is a gift—not just for others, but for the “future you” who’ll inevitably be dragged into debugging that mess. So, when in doubt, think, “Would I enjoy looking at this again?" Spoiler: if you wouldn’t, no one else will.
 
### 5 - Choose the Right Tool for the Job, Not Just the Trendiest Language

Let’s talk about programming language choice. Now, I get it—Rust is *amazing*. It’s fast, it’s safe, and honestly, if you could build a toaster with it, I’m sure the Rustaceans would insist on it (seriously, it’s only a matter of time). But here's the thing: just because Rust can do everything (including making your coffee, probably) doesn’t mean it should be your go-to for every project. Sure, Rust will make your code beautiful, performant, and give you a sense of accomplishment you can’t explain to anyone who doesn’t use Rust—but if you’re building a simple web app, maybe, just maybe, you don’t need to have a 30-minute discussion about ownership and lifetimes. 

Pick your language based on the task at hand. Rust is fantastic for system-level work, Python shines in rapid prototyping, and javascript—well, it's just javascript. Don’t let the cool factor push you into using the “next big thing” for things that would be way easier with an older, more established language. Rust may be great, but let’s not start using it to write a simple blog post API, okay? Your productivity will thank you later.


### 6 - Testing: Do It Now, Not Later (Seriously, Don't Skip It)

We've all been there—"I'll just add this feature and test it later." Spoiler: that "later" will come at 3 AM, during a production deploy, when you realize you've just accidentally broken the entire app. Testing is like flossing; it feels annoying at first, but doing it regularly prevents bigger problems down the road. Sure, unit tests can be boring, and the allure of “I know it works” is strong... until it doesn’t. Trust me, the time you save skipping tests will come back to haunt you. It's not *if* your app will break, it’s *when*. So, do yourself a favor: write tests now and avoid the dark pits of debugging in the middle of the night.

### 7 - Document Your Code (For the Future You Who’s About to Forget Everything)

Sure, you're a programming genius now, but let's be real: in three months, you’ll be staring at that code like it’s written in a foreign language (and not because it's in Java). No one likes writing documentation, but guess what? No one likes being confused by their own code, either. Write comments, explain your decision-making, and use descriptive variable names (no, “tempVar” doesn't cut it). Future-you will thank you when they don’t have to Google the API documentation you barely remember using, and neither will your teammates. If nothing else, it’ll save future-you from a headache when you inevitably ask, “Why did I do this?”

### 8 - Don’t Just Follow Tutorials—Solve Real Problems

Tutorials are great to learn the basics, but here’s the secret: the real growth happens when you take those basics and actually build something meaningful. Following step-by-step guides and copying-and-pasting code won't teach you much about *why* things work the way they do. The magic happens when you hit that problem that you don’t know how to solve and actually have to *think*. Sure, it’ll be frustrating, and you’ll probably get stuck a million times, but that's where the real learning happens. The more problems you solve, the more you’ll actually know how to use the tools you’ve learned. So, step away from tutorials and start making something that’ll actually make you think—and maybe even break a sweat.

### 9 - Don’t Try to Be the Best—Be the Best *You*

Tech culture loves to sell the idea that you need to be the “best” coder to succeed. But honestly, the only thing that matters is being the best version of *you*. It's great to admire the experts, but obsessing over your skills in comparison to others can do more harm than good. Focus on your own progress—work at your own pace, learn the tools that make sense to you, and embrace the fact that there’s no one right way to solve a problem. Besides, unless you’re inventing the next great language or technology (no pressure), there’s always someone better. So just focus on becoming your best self, and you'll be surprised at how much further you’ll go.

### Write code that you're proud of

As we step into 2025, remember that writing software isn’t just about lines of code—it’s about crafting solutions that work, scale, and (hopefully) don’t cause future-you to pull their hair out. Whether you're focused on memory management or avoiding the latest tech fad, the goal is the same: create software that serves a purpose, solves real problems, and doesn’t waste your time—or sanity.

So, let’s embrace the journey ahead with less worrying about perfection and more focus on what actually matters. Whether you’re using Rust, Python, or maybe something simpler, the key is making progress without getting bogged down in all the noise. And if you mess up, well, you’re a developer. It’s your job. Get used to it. Keep coding, keep learning, and most importantly, keep having fun. Happy 2025!
